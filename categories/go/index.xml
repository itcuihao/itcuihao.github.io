<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on haoc7</title>
    <link>http://cuihao.fun/categories/go/</link>
    <description>Recent content in Go on haoc7</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>Copyright (c) 2018 -, haoc7; all rights reserved.</copyright>
    <lastBuildDate>Sun, 19 Dec 2021 23:16:12 +0800</lastBuildDate><atom:link href="http://cuihao.fun/categories/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go Build</title>
      <link>http://cuihao.fun/post/go-build/</link>
      <pubDate>Sun, 19 Dec 2021 23:16:12 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/go-build/</guid>
      <description>在Go中利用此命令进行编译打包 go build [-o output] [build flags] [packages] 利用build编译时，会忽略_test.go结尾的文件； build时会默认使用文件名作为编译后的名字，如果是wind</description>
    </item>
    
    <item>
      <title>Go Timer</title>
      <link>http://cuihao.fun/post/go-timer/</link>
      <pubDate>Sat, 11 Dec 2021 21:59:22 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/go-timer/</guid>
      <description>假如有需求需要定时执行某一程序，会用到定时器，不过在设置定时器后想主动取消，就需要借助下context。 Go Timer 主动停止 package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;runtime/debug&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) func main() { mt := timerTest() time.Sleep(time.Second * 30) for i, tt</description>
    </item>
    
    <item>
      <title>配置文件热更新</title>
      <link>http://cuihao.fun/post/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%83%AD%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Tue, 24 Sep 2019 07:40:49 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%83%AD%E6%9B%B4%E6%96%B0/</guid>
      <description>想要使程序在不重启的前提下读取更新的配置文件，探索了以下几种方式： 信号量触发更新 API手动触发更新 监听文件触发更新 使用第三方包 一、信号量触发更新 对系统进程调用监</description>
    </item>
    
    <item>
      <title>Go的位操作四则运算实现</title>
      <link>http://cuihao.fun/post/go%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 02 Aug 2018 00:26:55 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/go%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0/</guid>
      <description>package main import &amp;quot;fmt&amp;quot; func main() { a := 2 b := 2 fmt.Println(add(a, b)) fmt.Println(sub(a, b)) fmt.Println(mul(a, b)) fmt.Println(div(a, b)) } func add(a, b int) int { if b == 0 { return a } tmp := 0 for b != 0 { tmp = (a &amp;amp; b) &amp;lt;&amp;lt; 1 a = a ^ b b = tmp } return a } func addr(a, b int) int { if b == 0 { return a } tmp := (a</description>
    </item>
    
    <item>
      <title>Catch and Redirect Panic</title>
      <link>http://cuihao.fun/post/catch-and-redirect-panic/</link>
      <pubDate>Mon, 30 Jul 2018 22:11:59 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/catch-and-redirect-panic/</guid>
      <description>面试的时候，面试官问程序panic了该怎么办；那就recover呀；后来想了下是不是守护进程呀。 那panic之后一般log会随着后台log一起打印，这样就不方便</description>
    </item>
    
  </channel>
</rss>
