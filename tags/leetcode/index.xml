<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on haoc7</title>
    <link>http://cuihao.fun/tags/leetcode/</link>
    <description>Recent content in Leetcode on haoc7</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>Copyright (c) 2018 -, haoc7; all rights reserved.</copyright>
    <lastBuildDate>Sun, 19 Apr 2020 19:40:53 +0800</lastBuildDate><atom:link href="http://cuihao.fun/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01 Matrix</title>
      <link>http://cuihao.fun/post/01-matrix/</link>
      <pubDate>Sun, 19 Apr 2020 19:40:53 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/01-matrix/</guid>
      <description>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 示例 1: 输入: 0 0 0 0 1 0 0 0 0 输出: 0 0 0 0 1 0 0 0 0 示例 2: 输入: 0 0 0 0 1</description>
    </item>
    
    <item>
      <title>BinaryTree的遍历</title>
      <link>http://cuihao.fun/post/binarytree%E7%9A%84%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 21 Apr 2019 19:35:37 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/binarytree%E7%9A%84%E9%81%8D%E5%8E%86/</guid>
      <description>在二叉树中有各种各样的遍历算法，下面然我们来看看它们是怎么实现的。 二叉树的结构： type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 递归 前序遍历 func preorderTraversal(root *TreeNode) []int { var l []int if root == nil { return l } l = append(l, root.Val) l = append(l,</description>
    </item>
    
    <item>
      <title>树中两个节点的最低公共祖先</title>
      <link>http://cuihao.fun/post/%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Mon, 15 Apr 2019 07:45:14 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>在《剑指Offer》7.2 章中，面试案例：树中两个节点的最低公共祖先，记录了如下面试流程： 面试官：让我们做一个编程题目吧。输入树的两个节点，求他们的最低公共祖先</description>
    </item>
    
    <item>
      <title>19.remove Nth Node From End of List</title>
      <link>http://cuihao.fun/post/19.remove-nth-node-from-end-of-list/</link>
      <pubDate>Wed, 01 Aug 2018 22:53:23 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/19.remove-nth-node-from-end-of-list/</guid>
      <description>Leetcode地址 Github地址 题干 Given a linked list, remove the n-th node from the end of list and return its head. 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 Example: Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the</description>
    </item>
    
    <item>
      <title>17.letter Combinations of a Phone Number</title>
      <link>http://cuihao.fun/post/17.letter-combinations-of-a-phone-number/</link>
      <pubDate>Thu, 26 Jul 2018 00:17:05 +0800</pubDate>
      
      <guid>http://cuihao.fun/post/17.letter-combinations-of-a-phone-number/</guid>
      <description>题目 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 给出数字到字母</description>
    </item>
    
  </channel>
</rss>
